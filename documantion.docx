Server Program Documentation
Overview
This server program is designed to:

Receive messages from Superchat via webhook.
Determine if the message should be processed by GPT based on specific labels.
Use OpenAI's GPT to generate responses for labeled messages.
Store non-GPT messages for context in future interactions.
Integrate with Zoho CRM for managing contacts and threads.
Project Structure
Main Files
index.js: The main server file that handles webhook requests and routes.
fetch.js: Contains functions to interact with OpenAI and Zoho CRM.
generateZohoToken.js: Handles generation of Zoho OAuth tokens.
gptFilter.js: Filters messages to determine if they should be processed by GPT.
sendMessagefromAttribute.js: Handles message sending based on attributes.
superchatFunctions.js: Functions to interact with Superchat API.
zohoFunctions.js: Functions to interact with Zoho CRM API.
Configuration Files
package.json: Contains project metadata and dependencies.
package-lock.json: Contains the exact versions of dependencies used.
Dependencies
External Libraries
@ngrok/ngrok
@zohocrm/nodejs-sdk-6.0
axios
body-parser
dotenv
express
openai
nodemon (dev dependency)
Environment Variables
BLOCK_AI_LEBEL
VIP_KUNDE_LEBEL
BESTANDSKUNDE_LEBEL
GPT_ATTRIBUTE
GPT_LEBEL
CLIENT_ID
CLIENT_SECRET
REDIRECT_URI
REFRESH_TOKEN
SUPERCHAT_API_KEY
SUPERCHATCHANNEL_ID
ZOHO_OAUTH_TOKEN
OPENAI_API_KEY
OPENAI_ASSISTANT
NGROK_TOKEN
PORT
Functionality
index.js
Server Setup: Uses Express to set up the server and define routes.
Webhook Endpoint: /webhook route to handle incoming messages from Superchat.
Run ChatGPT Endpoint: /runchatgpt route to manually trigger GPT processing.
fetch.js
call_in_OpenAi: Function to interact with OpenAI's API, manage threads, and update Zoho CRM records.
putMessageInThreadAssistant: Function to manage assistant messages within a thread.
generateZohoToken.js
generateZohoOauthToken: Generates and refreshes Zoho OAuth tokens for authentication.
gptFilter.js
runGpt: Filters messages based on labels to decide if they should be processed by GPT.
sendMessagefromAttribute.js
runThreadAndSend: Handles thread running and message sending based on contact attributes.
superchatFunctions.js
getSuperchatRecord: Retrieves contact records from Superchat.
sendMessage: Sends messages to contacts via Superchat.
getSuperchatConveration: Retrieves conversation records from Superchat.
zohoFunctions.js
initializeZohoCRM: Initializes Zoho CRM SDK.
updateRecord: Updates records in Zoho CRM.
createRecord: Creates new records in Zoho CRM.
Usage
Running the Server
Ensure all dependencies are installed using npm install.
Start the server with npm start.
Webhook Handling
The server listens for incoming messages from Superchat at the /webhook endpoint.
Messages are stored in memory and processed after a timeout period.
GPT Processing
Messages labeled with GPT are processed by OpenAI to generate responses.
The responses are sent back to the user via Superchat.
Zoho CRM Integration
Contacts and conversations are managed using Zoho CRM.
The server handles OAuth token generation and uses these tokens to interact with Zoho CRM APIs.
Environment Setup
Ensure the following environment variables are set in a .env file:

env
Copy code
BLOCK_AI_LEBEL=your_block_ai_label
VIP_KUNDE_LEBEL=your_vip_kunde_label
BESTANDSKUNDE_LEBEL=your_bestandskunde_label
GPT_ATTRIBUTE=your_gpt_attribute
GPT_LEBEL=your_gpt_label
CLIENT_ID=your_client_id
CLIENT_SECRET=your_client_secret
REDIRECT_URI=your_redirect_uri
REFRESH_TOKEN=your_refresh_token
SUPERCHAT_API_KEY=your_superchat_api_key
SUPERCHATCHANNEL_ID=your_superchat_channel_id
ZOHO_OAUTH_TOKEN=your_zoho_oauth_token
OPENAI_API_KEY=your_openai_api_key
OPENAI_ASSISTANT=your_openai_assistant
NGROK_TOKEN=your_ngrok
_token
PORT=your_port_number

php
Copy code

## Detailed Function Descriptions

### index.js
**Server Initialization and Route Handling:**
```javascript
import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import bodyParser from 'body-parser';
import { config } from 'dotenv';
import { call_in_OpenAi, putMessageInThreadAssistant } from './fetch.js';
import { runGpt } from './gptFilter.js';
import { runThreadAndSend } from './sendMessagefromAttribute.js';

config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3000;

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));
app.use(express.static(path.join(__dirname, 'public')));

app.get('/', (req, res) => {
    res.send('Hello World!');
});

let userInfo = {}; // To store user messages and timeouts

app.post('/webhook', (req, res) => {
    const response = req.body;
    const userId = response.message.from.id;
    const message = response.message.content.body;
    const userPhone = response.message.from.identifier;
    const superchat_contact_id = response.message.from.id;

    if (!userInfo[userId]) {
        userInfo[userId] = {
            messages: [],
            quickReplayBody: null,
            timeout: null,
            outbound: null,
            outboundReceived: false,
            messageType: null,
            template_id: null
        };
    }

    userInfo[userId].messages.push(message);
    userInfo[userId].phone = userPhone;
    userInfo[userId].superchat_contact_id = superchat_contact_id;

    if (userInfo[userId].timeout || userInfo[userId].outbound) {
        clearTimeout(userInfo[userId].timeout);
        clearTimeout(userInfo[userId].outbound);
    }

    userInfo[userId].timeout = setTimeout(() => {
        runGpt(superchat_contact_id, message, userPhone).then(isTrue => {
            if (isTrue === true) {
                console.log("User is not blocked");
                processUserMessages(userId);
            } else {
                userInfo[userId].outbound = setTimeout(() => {
                    if (userInfo[userId].outboundReceived && 
                        (userInfo[userId].template_id || userInfo[userId].quickReplayBody)) {
                        const template_id = userInfo[userId].template_id;
                        const quickReplayBody = userInfo[userId].quickReplayBody;
                        putMessageInThreadAssistant(template_id, quickReplayBody, userPhone);
                        console.log(`Outbound message received for user ${userId}`);
                    } else {
                        console.log(`Outbound message not received for user ${userId}`);
                    }
                    delete userInfo[userId];
                }, 10000);
            }
        }).catch(error => {
            console.error('Error:', error);
        });
    }, 20000);

    res.status(200).send('Webhook received');
});

app.listen(PORT, () => {
    console.log(`Server is running on http://localhost:${PORT}`);
});
fetch.js
Interacting with OpenAI and Zoho CRM:

javascript
Copy code
import axios from 'axios';
import dotenv from 'dotenv';
import { generateZohoOauthToken } from './generateZohoToken.js';
import OpenAI from "openai";
import { updateRecord, createRecord } from './zohoFunctions.js';
import { getSuperchatRecord, sendMessage } from './superchatFunctions.js';

dotenv.config();

const openai = new OpenAI();
const OPENAI_API_URL = 'https://api.openai.com/v1/';
const ZOHO_CRM_API_URL = 'https://www.zohoapis.eu/crm/v6/';
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const OPENAI_ASSISTANT = process.env.OPENAI_ASSISTANT;

const headers = {
    'Authorization': `Bearer ${OPENAI_API_KEY}`,
    'Content-Type': 'application/json',
    'OpenAI-Beta': 'assistants=v2'
};

export async function call_in_OpenAi(mg, phone, superchat_contact_id, checker) {
    let thread_id = null;
    let ZOHO_OAUTH_TOKEN = await generateZohoOauthToken();
    var record = null;

    try {
        const searchResponse = await axios.get(`${ZOHO_CRM_API_URL}Leads/search?phone=${phone}`, {
            headers: {
                'Authorization': `Zoho-oauthtoken ${ZOHO_OAUTH_TOKEN}`
            }
        });
        if (searchResponse) {
            record = searchResponse.data.data;
            if (record && record.length > 0) {
                thread_id = record[0].Thread_Id;
            }
        }
    } catch (error) {
        console.error('Error searching record in Zoho CRM:', error);
    }

    if (!thread_id) {
        const response = await axios.post(`${OPENAI_API_URL}threads`, {}, { headers });
        thread_id = response.data.id;
        const update_record = { Thread_Id: thread_id };

        if (record && record.length > 0) {
            const id = record[0].id;
            try {
                await axios.put(`${ZOHO_CRM_API_URL}Leads/${id}`, { data: [update_record] }, {
                    headers: {
                        'Authorization': `Zoho-oauthtoken ${ZOHO_OAUTH_TOKEN}`
                    }
                });
            } catch (error) {
                console.error('Error updating record in Zoho CRM:', error);
            }
        } else {
            update_record.Phone = phone;
            update_record.First_Name = getSuperchatRecord(superchat_contact_id).first_name ?? 'unknown';
            update_record.Last_Name = getSuperchatRecord(superchat_contact_id).last_name ?? 'unknown';
            try {
                await axios.post(`${ZOHO_CRM_API_URL}Leads`, { data: [update_record] }, {
                    headers: {
                        'Authorization': `Zoho-oauthtoken ${ZOHO_OAUTH_TOKEN}`
                    }
                });
            } catch (error) {
                console.error('Error creating record in Zoho CRM:', error);
            }
        }
    }

    let messageContent = null;
    if (mg) {
        try {
            const response1 = await openai.beta.threads.messages.create(thread_id, { role: "user", content: mg });
            const message_id = response1.id;

            if (checker === 1) {
                const run = await openai.beta.threads.runs.create(thread_id, { assistant_id: OPENAI_ASSISTANT });
                var run_status = run.status;
                while (run_status !== 'completed') {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    run_status = (await openai.beta.threads.runs.retrieve(thread_id, run.id)).status;
                }
                const threadMessages = await openai.beta.threads.messages.list(thread_id);
                const letMessage = threadMessages.data;
                messageContent = letMessage[0].content[0].text.value;
                sendMessage(messageContent, superchat_contact_id);
            }
        } catch (error) {
            console.error('Error updating thread or retrieving messages:', error);
        }
    }
    return thread_id;
}
generateZohoToken.js
Generating Zoho OAuth Tokens:

javascript
Copy code
import axios from 'axios';
import dotenv from 'dotenv';

dotenv.config();

const ZOHO_TOKEN_URL = 'https://accounts.zoho.eu/oauth/v2/token';
const CLIENT_ID = process.env.CLIENT_ID;
const CLIENT_SECRET = process.env.CLIENT_SECRET;
const REDIRECT_URI = process.env.REDIRECT_URI;
const REFRESH_TOKEN = process.env.REFRESH_TOKEN;

export async function generateZohoOauthToken() {
    try {
        const response = await axios.post(ZOHO_TOKEN_URL, null, {
            params: {
                client_id: CLIENT_ID,
                client_secret: CLIENT_SECRET,
                redirect_uri: REDIRECT_URI,
                refresh_token: REFRESH_TOKEN,
                grant_type: 'refresh_token'
            },
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            }
        });

        const { access_token, expires_in } = response.data;
        process.env.ZOHO_OAUTH_TOKEN = access_token;
        return access_token;
    } catch (error) {
        console.error('Error generating Zoho OAuth token:', error.response ? error.response.data : error.message);
        throw error;
    }
}
gptFilter.js
Filtering Messages for GPT Processing:

javascript
Copy code
import { getSuperchatRecord, getSuperchatConveration } from './superchatFunctions.js';
import { config } from 'dotenv';
import { call_in_OpenAi } from './fetch.js';

config();

const blockingLebels = [
    process.env.BLOCK_AI_LEBEL,
    process.env.VIP_KUNDE_LEBEL,
    process.env.BESTANDSKUNDE_LEBEL,
];
const gpt_attribute_id = process.env.GPT_ATTRIBUTE;
const gpt_lebel = process.env.GPT_LEBEL;

export async function runGpt(contact_id, mg, phone) {
    const contact_record = await getSuperchatRecord(contact_id);
    const conversation_record = await getSuperchatConveration(contact_id);
    const lebels = conversation_record.results[0].labels;
    const custom_attributes = contact_record.custom_attributes;
    let checker = 0;

    lebels.forEach(lebel => {
        if (lebel.id === gpt_lebel) {
            checker = 1;
            lebels.forEach(lebel_1 => {
                if (blockingLebels.includes(lebel_1.id)) {
                    checker = 0;
                }
            });
        }
    });

    if (checker === 0) {
        call_in_OpenAi(mg, phone, contact_id, 0);
        return false;
    } else {
        return true;
    }
}
sendMessagefromAttribute.js
Handling Message Sending Based on Attributes:

javascript
Copy code
import { config } from 'dotenv';
import { generateZohoOauthToken } from './generateZohoToken.js';
import OpenAI from "openai";
import axios from 'axios';
import { sendMessage } from './superchatFunctions.js';

config();

export async function runThreadAndSend(contact) {
    const ZOHO_CRM_API_URL = 'https://www.zohoapis.eu/crm/v6/';
    let record = null;
    let thread_id = null;
    let ZOHO_OAUTH_TOKEN = await generateZohoOauthToken();
    const openai = new OpenAI();
    const OPENAI_ASSISTANT = process.env.OPENAI_ASSISTANT;
    let phone = null;
    let messageContent = null;

    contact.handles.forEach(handle => {
        if (handle.type === 'phone') {
            phone = handle.value.toString();
        }
    });

    try {
        const searchResponse = await axios.get(`${ZOHO_CRM_API_URL}Leads/search?phone=${phone}`, {
            headers: {
                'Authorization': `Zoho-oauthtoken ${ZOHO_OAUTH_TOKEN}`
            }
        });
        if (searchResponse) {
            record = searchResponse.data.data;
            if (record && record.length > 0) {
                thread_id = record[0].Thread_Id;
            }
            if (thread_id) {
                const run = await openai.beta.threads.runs.create(thread_id, { assistant_id: OPENAI_ASSISTANT });
                var run_status = run.status;
                while (run_status !== 'completed') {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    run_status = (await openai.beta.threads.runs.retrieve(thread_id, run.id)).status;
                }
                const threadMessages = await openai.beta.threads.messages.list(thread_id);
                const letMessage = threadMessages.data;
                messageContent = letMessage[0].content[0].text.value;
                // sendMessage(messageContent, contact.id);
            }
        } else {
            console.log('No Lead found');
        }
    } catch (error) {
        console.error('Error searching record in Zoho CRM in putMessageInThreadAssistant:', error);
    }
}
superchatFunctions.js
Superchat API Interactions:

javascript
Copy code
import { config } from 'dotenv';

config();

const SUPERCHAT_API_KEY = process.env.SUPERCHAT_API_KEY;
const SUPERCHATCHANNEL_ID = process.env.SUPERCHATCHANNEL_ID;

export async function getSuperchatRecord(contact_id) {
    const options = {
        method: 'GET',
        headers: {
            accept: 'application/json',
            'X-API-KEY': SUPERCHAT_API_KEY
        }
    };

    return fetch(`https://api.superchat.com/v1.0/contacts/${contact_id}`, options)
        .then(response => response.json())
        .catch(err => console.error(err));
}

export async function sendMessage(message, contact_id) {
    const options = {
        method: 'POST',
        headers: {
            accept: 'application/json',
            'content-type': 'application/json',
            'X-API-KEY': SUPERCHAT_API_KEY
        },
        body: JSON.stringify({
            to: [{ identifier: contact_id }],
            from: { channel_id: SUPERCHATCHANNEL_ID, name: 'WhatsApp' },
            content: { type: 'text', body: JSON.stringify(message) }
        })
    };

    fetch('https://api.superchat.com/v1.0/messages', options)
        .then(response => response.json())
        .catch(err => console.error(err));
}

export async function getSuperchatConveration(contact_id) {
    const options = {
        method: 'GET',
        headers: {
            accept: 'application/json',
            'X-API-KEY': SUPERCHAT_API_KEY
        }
    };

    return fetch(`https://api.superchat.com/v1.0/contacts/${contact_id}/conversations`, options)
        .then(response => response.json())
        .catch(err => console.error(err));
}
zohoFunctions.js
Zoho CRM Interactions:

javascript
Copy code
import * as ZOHOCRMSDK from "@zohocrm/nodejs-sdk-6.0";
import { config } from 'dotenv';
import { getSuperchatRecord } from './superchatFunctions.js';

config();

const client_id = process.env.CLIENT_ID;
const client_secret = process.env.CLIENT_SECRET;
const redirect_url = process.env.REDIRECT_URI;
const refresh_token = process.env.REFRESH_TOKEN;

export async function initializeZohoCRM() {
    const environment = ZOHOCRMSDK.EUDataCenter.PRODUCTION();
    const token = new ZOHOCRMSDK.OAuthBuilder()
        .clientId(client_id)
        .clientSecret(client_secret)
        .refreshToken(refresh_token)
        .redirectURL(redirect_url)
        .build();

    const builder = new ZOHOCRMSDK.InitializeBuilder();
    builder.environment(environment);
    builder.token(token);
    await builder.initialize();
}

export async function updateRecord(recordId, thread_id) {
    try {
        const moduleAPIName = "Leads";
        const recordOperations = new ZOHOCRMSDK.Record.RecordOperations();
        const record = new ZOHOCRMSDK.Record.Record();
        record.addFieldValue(ZOHOCRMSDK.Record.Field.Leads.THREAD_ID, thread_id);

        const records = [record];
        const request = new ZOHOCRMSDK.Record.BodyWrapper();
        request.setData(records);

        const response = await recordOperations.updateRecord(recordId, moduleAPIName, request);

        if (response != null) {
            console.log("Status Code: ", response.getStatusCode());
            console.log("Response: ", response.getObject());
        }
    } catch (error) {
        console.error("Error updating record:", error);
    }
}

export async function createRecord(phone, thread_id, superchat_contact_id) {
    try {
        initializeZohoCRM();
        const moduleAPIName = "Leads";
        const superchatRecord = await getSuperchatRecord(superchat_contact_id);
        const recordOperations = new ZOHOCRMSDK.Record.RecordOperations();
        const record = new ZOHOCRMSDK.Record.Record();
        record.addFieldValue(ZOHOCRMSDK.Record.Field.Leads.FIRST_NAME, superchatRecord.first_name);
        record.addFieldValue(ZOHOCRMSDK.Record.Field.Leads.LAST_NAME, superchatRecord.last_name);
        record.addFieldValue(ZOHOCRMSDK.Record.Field.Leads.Phone, phone);
        record.addFieldValue(ZOHOCRMSDK.Record.Field.Leads.THREAD_ID, thread_id);

        const records = [record];
        const request = new ZOHOCRMSDK.Record.BodyWrapper();
        request.setData(records);

        const response = await recordOperations.createRecords(moduleAPIName, request);

        if (response != null) {
            console.log("Status Code: ", response.getStatusCode());
            console.log("Response: ", response.getObject());
        }
    } catch (error) {
        console.error("Error creating record:", error);
    }
}
This documentation outlines the structure, dependencies, and functionality of your server program, providing a comprehensive guide to understand and manage your project effectively.